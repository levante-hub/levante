import { useState, useCallback, useEffect } from 'react'
import { UIMessage } from 'ai'
import { useChatSession } from './useChatSession'
import { Message } from '../../types/database'

// Use AI SDK compatible status types
export type ElectronChatStatus = 'ready' | 'streaming' | 'submitted' | 'error'

export interface ElectronMessage {
  id: string
  role: 'user' | 'assistant' | 'system'
  content: string
  parts: Array<{
    type: 'text' | 'source-url' | 'reasoning'
    text?: string
    url?: string
  }>
}

export interface UseElectronChatOptions {
  body?: {
    model?: string
    webSearch?: boolean
  }
}

export interface UseElectronChatResult {
  messages: ElectronMessage[]
  status: ElectronChatStatus
  sendMessage: (message: { text: string }, options?: UseElectronChatOptions) => Promise<void>
  
  // Session management
  currentSession: any
  sessions: any[]
  createNewChat: (title?: string) => Promise<void>
  loadChat: (sessionId: string) => Promise<void>
  deleteChat: (sessionId: string) => Promise<void>
}

// Helper to convert DB Message to ElectronMessage
function convertToElectronMessage(dbMessage: Message): ElectronMessage {
  return {
    id: dbMessage.id,
    role: dbMessage.role,
    content: dbMessage.content,
    parts: [{ type: 'text', text: dbMessage.content }]
  };
}

export function useElectronChat(): UseElectronChatResult {
  const [messages, setMessages] = useState<ElectronMessage[]>([])
  const [status, setStatus] = useState<ElectronChatStatus>('ready')
  const [streamingMessage, setStreamingMessage] = useState<ElectronMessage | null>(null)
  
  // Use session management
  const {
    currentSession,
    sessions,
    messages: dbMessages,
    createSession,
    loadSession,
    deleteSession,
    addMessage,
    error: sessionError
  } = useChatSession()

  // Convert DB messages to ElectronMessages and include streaming message
  useEffect(() => {
    const electronMessages = dbMessages.map(convertToElectronMessage);
    
    // Add streaming message if active
    if (streamingMessage) {
      setMessages([...electronMessages, streamingMessage]);
    } else {
      setMessages(electronMessages);
    }
  }, [dbMessages, streamingMessage]);

  const sendMessage = useCallback(async (
    message: { text: string }, 
    options?: UseElectronChatOptions
  ) => {
    const { model = 'openai/gpt-4o', webSearch = false } = options?.body || {}
    
    // Ensure we have a session
    let session = currentSession;
    if (!session) {
      console.log('[useElectronChat] Creating new session for message');
      session = await createSession(`Chat - ${new Date().toLocaleTimeString()}`, model);
      if (!session) {
        setStatus('error');
        return;
      }
    }
    
    setStatus('submitted');
    
    try {
      // 1. Save user message to database
      const userDbMessage = await addMessage(message.text, 'user');
      if (!userDbMessage) {
        setStatus('error');
        return;
      }
      
      // 2. Create streaming assistant message
      const streamingId = `streaming_${Date.now()}`;
      const streamingAssistantMessage: ElectronMessage = {
        id: streamingId,
        role: 'assistant',
        content: '',
        parts: []
      };
      
      setStreamingMessage(streamingAssistantMessage);
      setStatus('streaming');
      
      // 3. Prepare API messages from database history + user message
      const apiMessages: UIMessage[] = [...dbMessages, userDbMessage].map(msg => ({
        id: msg.id,
        role: msg.role,
        content: msg.content,
        parts: [{ type: 'text' as const, text: msg.content }]
      }));
      
      let fullResponse = '';
      
      // 4. Stream the response
      await window.levante.streamChat(
        {
          messages: apiMessages,
          model,
          webSearch
        },
        (chunk) => {
          if (chunk.delta) {
            fullResponse += chunk.delta;
            
            // Update streaming message
            setStreamingMessage(prev => prev ? {
              ...prev,
              content: fullResponse,
              parts: [{ type: 'text', text: fullResponse }]
            } : null);
          }
          
          if (chunk.sources) {
            setStreamingMessage(prev => prev ? {
              ...prev,
              parts: [
                ...prev.parts,
                ...chunk.sources!.map(source => ({
                  type: 'source-url' as const,
                  url: source.url
                }))
              ]
            } : null);
          }
          
          if (chunk.reasoning) {
            setStreamingMessage(prev => prev ? {
              ...prev,
              parts: [
                ...prev.parts,
                { type: 'reasoning', text: chunk.reasoning! }
              ]
            } : null);
          }
          
          if (chunk.done) {
            // 5. Save assistant message to database when streaming is complete
            if (fullResponse) {
              addMessage(fullResponse, 'assistant').then(() => {
                setStreamingMessage(null);
                setStatus('ready');
              });
            } else {
              setStreamingMessage(null);
              setStatus('ready');
            }
          }
        }
      );
      
    } catch (error) {
      console.error('[useElectronChat] Chat error:', error);
      setStatus('error');
      
      // Save error message to database
      await addMessage('Sorry, there was an error processing your request.', 'assistant');
      setStreamingMessage(null);
    }
  }, [currentSession, createSession, addMessage, dbMessages]);

  // Session management functions
  const createNewChat = useCallback(async (title?: string) => {
    const session = await createSession(title);
    if (session) {
      console.log('[useElectronChat] New chat created:', session.id);
    }
  }, [createSession]);

  const loadChat = useCallback(async (sessionId: string) => {
    await loadSession(sessionId);
    console.log('[useElectronChat] Chat loaded:', sessionId);
  }, [loadSession]);

  const deleteChat = useCallback(async (sessionId: string) => {
    const success = await deleteSession(sessionId);
    if (success) {
      console.log('[useElectronChat] Chat deleted:', sessionId);
    }
  }, [deleteSession]);

  // Log session errors
  useEffect(() => {
    if (sessionError) {
      console.error('[useElectronChat] Session error:', sessionError);
      setStatus('error');
    }
  }, [sessionError]);

  return {
    messages,
    status,
    sendMessage,
    currentSession,
    sessions,
    createNewChat,
    loadChat,
    deleteChat
  }
}